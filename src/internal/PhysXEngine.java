package internal;

import Autopilot.AutopilotConfig;
import Autopilot.AutopilotInputs;
import Autopilot.AutopilotOutputs;
import org.lwjgl.system.CallbackI;
import sun.font.PhysicalFont;

import static java.lang.Math.*;


/**
 * Created by Martijn on 6/11/2017.
 * A class of physics engines used for the drone and the autopilot
 */
public class PhysXEngine {

    /**
     * Constructor for a physics engine
     * @param configuration the configuration of the engine
     * @author
     */
    public PhysXEngine(AutopilotConfig configuration){

        this.setPhysXEngineConfig(configuration);

        this.setMainRight(new HorizontalWingPhysX(new Vector(configuration.getWingX(),0f, 0f),
                configuration.getWingLiftSlope(), configuration.getWingMass(), configuration.getMaxAOA(), 0));
        this.setMainLeft(new HorizontalWingPhysX(new Vector(-configuration.getWingX(), 0f, 0f),
                configuration.getWingLiftSlope(), configuration.getWingMass(), configuration.getMaxAOA(), 0));
        this.setHorizontalStabilizer(new HorizontalWingPhysX(new Vector(0,0, configuration.getTailSize()),
                configuration.getHorStabLiftSlope(), configuration.getTailMass(), configuration.getMaxAOA(), 0));
        this.setVerticalStabilizer(new VerticalWingPhysX(new Vector(0,0, configuration.getTailSize()),
                configuration.getVerStabLiftSlope(), configuration.getTailMass(), configuration.getMaxAOA(), 0));

        this.setEnginePosition();
        this.setInertiaTensor();


    }

    /**
     * Calculates the next state of the drone for the given input
     * @param deltaTime the time step for the next state
     * @param inputs the outputs generated by the autopilot
     * @param position the position of the drone at moment t
     * @param velocity the velocity of the drone at moment t
     * @param orientation the orientation at moment t
     * @param rotation the rotation at moment t
     * @param INSIGNIFICANCE factor to ignore small drift in the model
     * @return a PhysicsEngineState object containing the state of the drone at moment t + deltaTime
     * @author Martijn Sauwens
     */
    public PhysicsEngineState getNextStatePhysXEngine(float deltaTime, AutopilotOutputs inputs,  Vector position, Vector velocity, Vector orientation, Vector rotation, float INSIGNIFICANCE){

        //adjust the inclinations of the wings
        this.getMainRight().setWingInclination(inputs.getRightWingInclination());
        this.getMainLeft().setWingInclination(inputs.getLeftWingInclination());
        this.getHorizontalStabilizer().setWingInclination(inputs.getHorStabInclination());
        this.getVerticalStabilizer().setWingInclination(inputs.getVerStabInclination());

        if(this.flightRecorder != null){
            this.recordWingState(orientation, rotation, velocity);
        }

        //check if the thrust is valid
        if(!canHaveAsThrust(inputs.getThrust())) {
        	System.out.println(inputs.getThrust());
        	throw new IllegalArgumentException(THRUST_OUT_OF_RANGE);
        }
            
        Vector thrustVector = new Vector(0.f, 0.f, -inputs.getThrust());

        // calculate the next position & velocity
        Vector acceleration = this.calcAcceleration(thrustVector, orientation, rotation, velocity);
        Vector nextVelocity = this.getNextVelocity(deltaTime, acceleration, velocity);
        Vector nextPosition = this.getNextPosition(deltaTime, acceleration, position, velocity);
        Vector angularAcceleration = this.calcAngularAcceleration(orientation, rotation, velocity);
        Vector angularAccelerationWorld = droneOnWorld(angularAcceleration, orientation);
        Vector nextRotation = this.getNextRotationVector(deltaTime, angularAccelerationWorld, rotation);
        //Vector nextRotation = this.getNextRotationCauchy(deltaTime, orientation, rotation, velocity);
        //Vector nextRotation = this.getNextRotationRK4(deltaTime, orientation, rotation, velocity);
        Vector nextOrientation = this.getNextOrientation(deltaTime, angularAccelerationWorld, orientation, rotation);

        PhysicsEngineState state = new PhysicsEngineState() {
            @Override
            public Vector getPosition() {
               return  position.driftRejection(nextPosition, INSIGNIFICANCE*deltaTime);
            }

            @Override
            public Vector getVelocity() {
                return velocity.driftRejection(nextVelocity, INSIGNIFICANCE*deltaTime);
            }

            @Override
            public Vector getOrientation() {
                return normalizeOrientation(orientation.driftRejection(nextOrientation, INSIGNIFICANCE*deltaTime));
            }

            @Override
            public Vector getRotation() {
                return rotation.driftRejection(nextRotation, INSIGNIFICANCE*deltaTime);
            }
        };

        if(this.getFlightRecorder() != null){
            this.recordEngineState(state);
        }

        return state;
    }

    private void recordWingState(Vector orientation, Vector rotation, Vector velocity){
        FlightRecorder flightRecorder = this.getFlightRecorder();
        WingPhysX rightMain = this.getMainRight();
        WingPhysX leftMain = this.getMainLeft();
        WingPhysX horStab = this.getHorizontalStabilizer();
        WingPhysX verStab = this.getVerticalStabilizer();

        float CONVERSION = 180/(float)Math.PI;

        //log the right wing
        flightRecorder.appendRightMainInclLog(rightMain.getWingInclination()*CONVERSION);
        float rightAOA = rightMain.calcAngleOfAttack(orientation, rotation, velocity);
        flightRecorder.appendRightMainAOALog(rightAOA*CONVERSION);

        //log the left wing
        flightRecorder.appendLeftMainInclLog(leftMain.getWingInclination()*CONVERSION);
        float leftAOA = leftMain.calcAngleOfAttack(orientation, rotation, velocity);
        flightRecorder.appendLeftMainAOALog(leftAOA*CONVERSION);

        //log the horStabilizer
        flightRecorder.appendHorStabInclLog(horStab.getWingInclination()*CONVERSION);
        float horStabAOA = horStab.calcAngleOfAttack(orientation, rotation, velocity);
        flightRecorder.appendHorStabAOALog(horStabAOA*CONVERSION);

        //log the verStabilizer
        flightRecorder.appendVerStabInclLog(verStab.getWingInclination()*CONVERSION);
        float verStabAOA = verStab.calcAngleOfAttack(orientation, rotation, velocity);
        flightRecorder.appendVerStabAOALog(verStabAOA*CONVERSION);
    }

    private void recordEngineState(PhysicsEngineState state){
        FlightRecorder flightRecorder = this.getFlightRecorder();
        //the state of the drone
        flightRecorder.appendPositionLog(state.getPosition());
        flightRecorder.appendVelocityLog(state.getVelocity());
        flightRecorder.appendOrientationLog(state.getOrientation());
        flightRecorder.appendRotationLog(state.getRotation());
    }

    /**
     * Calculate the next rotation  using the Cauchy method
     * assumption made: Orientation doesn't change during the calculation (so also no change in velocity)
     * @return the angular acceleration of the drone
     * @author Martijn Sauwens
     */
    private Vector getNextRotationCauchy(float deltaTime, Vector orientation, Vector rotation, Vector velocity){

        Vector k1 = droneOnWorld(this.calcAngularAcceleration(orientation, rotation, velocity), orientation);
        Vector rotationK1 = rotation.vectorSum(k1.scalarMult(deltaTime/2)); // yk + h/2*k1 with h the step size
        //fill in the new orientation to calculate the next angular acceleration
        Vector k2 = droneOnWorld(this.calcAngularAcceleration(orientation, rotationK1, velocity), orientation);
        return rotation.vectorSum(k2.scalarMult(deltaTime));
    }

    /**
     * Calculate the next rotation using the Runge Kutta differentiation method
     * @param deltaTime the timestep
     * @param orientation the orientation
     * @param rotation the rotation
     * @param velocity the velocity
     * @return a vector containing the angular acceleration of the drone
     * @author Martijn Sauwens
     */
    private Vector getNextRotationRK4(float deltaTime, Vector orientation, Vector rotation, Vector velocity){
        Vector k1 =  droneOnWorld(this.calcAngularAcceleration(orientation, rotation, velocity), orientation);
        Vector rotationK1 = rotation.vectorSum(k1.scalarMult(deltaTime/2.0f));
        Vector k2 =  droneOnWorld(this.calcAngularAcceleration(orientation, rotationK1, velocity), orientation);
        Vector rotationK2 = rotation.vectorSum(k2.scalarMult(deltaTime/2.0f));
        Vector k3 =   droneOnWorld(this.calcAngularAcceleration(orientation, rotationK2, velocity), orientation);
        Vector rotationK3 = rotation.vectorSum(k3.scalarMult(deltaTime));
        Vector k4 =  droneOnWorld(this.calcAngularAcceleration(orientation, rotationK3, velocity), orientation);

        Vector result = (k1.vectorSum(k2.scalarMult(2.0f)).vectorSum(k3.scalarMult(2.0f)).vectorSum(k4)).scalarMult(deltaTime/6.0f);
        return orientation.vectorSum(result);
    }


    /*
    Transformations
     */
    /**
     * projects a vector of the drone axis on the world axis
     *
     * @param vector the vector to project
     * @param orientation the orientation of the drone (heading, pitch, roll)
     * @return a new vector containing the projection
     * @author Martijn Sauwens
     */
    public static Vector droneOnWorld(Vector vector, Vector orientation) {
        return getDroneToWorldTransformMatrix(orientation).matrixVectorProduct(vector);
    }

    /**
     * projects a vector in the world axis to a vector in the drone axis
     *
     * @param vector the vector to project on the drone axis
     * @param orientation the orientation of the drone (heading, pitch, roll)
     * @return a new vector containing the projection
     * @author Martijn Sauwens
     */
    public static Vector worldOnDrone(Vector vector, Vector orientation) {
        SquareMatrix transform = getDroneToWorldTransformMatrix(orientation);
        SquareMatrix transpose = transform.transpose();

        return transpose.matrixVectorProduct(vector);
    }

    /**
     * Calculates the transformation matrix for the drone to world axis
     * @param orientation the orientation of the drone (heading, pitch, roll)
     * @return a square matrix containing the transformation matrix for the current drone configuration;
     * @author Jasper Callaerts & Martijn Sauwens
     */
    private static SquareMatrix getDroneToWorldTransformMatrix(Vector orientation) {
        SquareMatrix heading = SquareMatrix.getHeadingTransformMatrix(orientation.getxValue());
        SquareMatrix pitch = SquareMatrix.getPitchTransformMatrix(orientation.getyValue());
        SquareMatrix roll = SquareMatrix.getRollTransformMatrix(orientation.getzValue());

        return heading.matrixProduct(pitch).matrixProduct(roll);
    }

    public static Vector HPRtoRotation(Vector rotationHPR, Vector orientation){
        float heading = orientation.getxValue();
        float pitch = orientation.getyValue();
        float headingRotation = rotationHPR.getxValue();
        float pitchRotation = rotationHPR.getyValue();
        float rollRotation = rotationHPR.getzValue();
        float xRotation = (float) (pitchRotation*cos(heading) + rollRotation*sin(heading)*cos(pitch));
        float yRotation = (float) (- rollRotation * sin(pitch)  + headingRotation);
        float zRotation = (float)( - pitchRotation*sin(heading) + rollRotation*cos(heading)*cos(pitch));

        return new Vector(xRotation, yRotation, zRotation);
    }

    /**
     * Calculates the projection of the provided rotation vector
     * @param rotationVector the rotation vector to be projected
     * @param orientation the orientation of the drone (heading, pitch, roll)
     * @return a vector containing the heading, pitch and roll rotation vector
     * 		   the vector has the following format:
     * 		   Vector(headingRotation, pitchRotation, rollRotation)
     * 		   for more info concering the projection see the individual transformation functions
     * note: see notes on the calculations for clarification
     * @author Martijn Sauwens
     */
    public static Vector getRotationHPR(Vector rotationVector, Vector orientation){
        Vector headingRotation = getHeadingRotationVector(rotationVector, orientation);
        Vector pitchRotation = getPitchRotationVector(rotationVector, orientation);
        Vector rollRotation = getRollRotationVector(rotationVector, orientation);

        Vector sumHeadingPitch = headingRotation.vectorSum(pitchRotation);
        return sumHeadingPitch.vectorSum(rollRotation);
    }


    /**
     * Calculates the heading rotation vector component for a given rotation vector
     * the heading vector stands always with the y-axis in the world axis system
     * @param rotationVector the rotation vector to be projected
     * @param orientation the orientation of the drone (heading, pitch, roll)
     * @return a vector containing the heading rotation (given in the same format as the orientation vectors)
     * 		   return new Vector( projectedHeading, 0, 0 )
     * @author Martijn Sauwens
     */
    private static Vector getHeadingRotationVector(Vector rotationVector, Vector orientation){
        float heading = orientation.getxValue();
        float pitch = orientation.getyValue();

        float part1 = rotationVector.getyValue();
        float part2 = (float) (rotationVector.getzValue()*Math.cos(heading)* tan(pitch));
        float part3 = (float) (rotationVector.getxValue()*Math.sin(heading)* tan(pitch));

        float result = part1 + part2 + part3;

        return new Vector(result, 0.0f, 0.0f);
    }


    /**
     * Calculates the pitch rotation vector component for a given rotation vector
     * the pitch vector stands parallel to the x axis after the heading transformation
     * has been applied to the world axis system
     * @param rotationVector the rotation vector to be projected
     * @param orientation the orientation of the drone (heading, pitch, roll)
     * @return a vector containing the pitch rotation, given in the heading transformed world axis system
     * 		   return new Vector (0 , projectedPitch, 0)
     * @author Martijn Sauwens
     */
    private static Vector getPitchRotationVector(Vector rotationVector, Vector orientation){
        float heading = orientation.getxValue();

        float part1 = (float) (rotationVector.getxValue()*Math.cos(heading));
        float part2 = (float) (- rotationVector.getzValue()*Math.sin(heading));

        float result = part1 + part2;

        return new Vector(0.0f, result, 0.0f);
    }

    /**
     * Calculates the roll rotation vector component for a given rotation vector
     * the roll vector stands parallel to the the z- axis after the heading and the pitch transformation
     * has been applied to the world axis system
     * @param rotationVector the rotation vector to be projected
     * @param orientation the orientation of the drone (heading, pitch, roll)
     * @return a vector containing the roll rotation, given in the double transformed world axis system
     * 		   return new Vector(0, 0, rollRotationVector)
     *
     * @author Martijn Sauwens
     */
    private static Vector getRollRotationVector(Vector rotationVector, Vector orientation){
        float heading = orientation.getxValue();
        float pitch = orientation.getyValue();

        float part1 = (float) (rotationVector.getxValue()*Math.sin(heading));
        float part2 = (float) (rotationVector.getzValue()*Math.cos(heading));

        float result = (float) ((part1 + part2)/Math.cos(pitch));

        return new Vector(0.0f, 0.0f, result);

    }

    /**
     * Calculates the angular acceleration in the heading, pitch, roll system for a given
     * angular acceleration vector
     * @param angularAccelerationVector the angular acceleration vector in the world axis system
     * @return a vector of format (HeadingAcceleration, PitchAcceleration, RollAcceleration)
     * @author Martijn Sauwens
     */
    private Vector getAngularAccelerationHPR(Vector angularAccelerationVector, Vector orientation, Vector rotationVector){
        float headingAcceleration = this.getHeadingAngularAcceleration(angularAccelerationVector, orientation, rotationVector);
        float pitchAcceleration = this.getPitchAngularAcceleration(angularAccelerationVector, orientation, rotationVector);
        float rollAcceleration = this.getRollAngularAcceleration(angularAccelerationVector, orientation, rotationVector);

        return new Vector(headingAcceleration, pitchAcceleration, rollAcceleration);
    }

    /**
     * Calculates the heading angular acceleration component for the given angular acceleration vector
     * the heading acceleration vector stands parallel to the y-axis in the world axis system
     * @param angularAccelerationVector the vector containing the angular acceleration given in the
     *                                  world-axis system
     * @param orientation the current orientation of the drone (heading, pitch, roll)
     * @param rotationVector the current rotation vector of the drone, given in the world axis system
     * @return the heading angular acceleration
     * @author Martijn Sauwens
     */
    private float getHeadingAngularAcceleration(Vector angularAccelerationVector, Vector orientation, Vector rotationVector){
        float heading = orientation.getxValue();
        float pitch = orientation.getyValue();
        Vector AAVector = angularAccelerationVector;

        float headingRotation = this.getHeadingRotationVector(rotationVector, orientation).getxValue();
        float pitchRotation = this.getPitchRotationVector(rotationVector, orientation).getyValue();

        //split up in parts for convenience
        float part1 = (float) (AAVector.getyValue() + AAVector.getzValue()*Math.cos(heading)* tan(pitch));
        float part2 = (float) (-rotationVector.getzValue()*headingRotation*Math.sin(heading)* tan(pitch));
        float part3 = (float) (rotationVector.getzValue()*pitchRotation*Math.cos(heading)/(Math.cos(pitch)*Math.cos(pitch)));
        float part4 = (float) (AAVector.getxValue()*Math.sin(heading)* tan(pitch));
        float part5 = (float) (rotationVector.getxValue()*headingRotation*Math.cos(heading)* tan(pitch));
        float part6 = (float) (rotationVector.getxValue()*pitchRotation*Math.sin(heading)/(Math.cos(pitch)*Math.cos(pitch)));

        return part1 + part2 + part3 + part4 + part5 + part6;
    }
    /**
     * Calculates the pitch angular acceleration component for the given angular acceleration vector
     * the pitch acceleration vector stands parallel to the x-axis after the heading transformation
     * of the world axis system
     * @param angularAccelerationVector the vector containing the angular acceleration
     *                                  given in the world-axis system
     * @param orientation the orientation of the drone (heading, pitch, roll)
     * @param rotationVector the rotation of the drone given in the world axis system
     * @return the pitch angular acceleration
     * @author Martijn Sauwens
     */
    private float getPitchAngularAcceleration(Vector angularAccelerationVector, Vector orientation, Vector rotationVector){
        float heading = orientation.getxValue();
        Vector AAVector = angularAccelerationVector;

        float headingRotation = this.getHeadingRotationVector(rotationVector, orientation).getxValue();
        //split up in parts for convenience
        float part1 = (float) (AAVector.getxValue()*Math.cos(heading) - rotationVector.getxValue()*headingRotation*Math.sin(heading));
        float part2 = (float) (- AAVector.getzValue()*Math.sin(heading) - rotationVector.getzValue()*headingRotation*Math.cos(heading));
        return part1 + part2;
    }

    /**
     * Calculates the roll angular acceleration component for the given angular acceleration vector
     * the roll acceleration stands parallel to the z-axis after the heading and the pitch transformation
     * of the world axis system (in that order)
     * @param angularAccelerationVector the vector containing the angular acceleration
     *                                  given in the world-axis system
     * @param orientation the orientation of the drone (heading, pitch, roll)
     * @param rotationVector the rotation vector of the drone, given in the world axis system
     * @return the roll angular acceleration
     * @author Martijn Sauwens
     */
    private float getRollAngularAcceleration(Vector angularAccelerationVector, Vector orientation, Vector rotationVector){
        float heading = orientation.getxValue();
        float pitch = orientation.getyValue();
        Vector AAVector = angularAccelerationVector;

        float headingRotation = getHeadingRotationVector(rotationVector, orientation).getxValue();
        float pitchRotation = getPitchRotationVector(rotationVector, orientation).getyValue();

        //split up for convenience
        float part1 = (float) (AAVector.getzValue()*Math.cos(heading)/Math.cos(pitch) -
                rotationVector.getzValue()*headingRotation*Math.sin(heading)/Math.cos(pitch));
        float part2 = (float) (rotationVector.getzValue()*pitchRotation*Math.sin(heading)*Math.sin(pitch)/(Math.cos(pitch)*Math.cos(pitch)));
        float part3 = (float) (AAVector.getxValue()*Math.sin(heading)/Math.cos(pitch) + rotationVector.getxValue()
                *headingRotation*Math.cos(heading)/Math.cos(pitch));
        float part4 = (float) (rotationVector.getxValue()*pitchRotation*Math.sin(heading)*Math.sin(pitch)/(Math.cos(pitch)*Math.cos(pitch)));

        return part1 + part2 + part3 + part4;
    }


    /*
    Next state methods
     */

    /**
     * calculates the next orientation based on the current orientation and the angular acceleration
     * @param deltaTime the time step taken
     * @param angularAcceleration the angular acceleration
     * @param currentOrientation the orientation of the drone (heading, pitch, roll)
     * @param currentRotation the rotation vector of the drone, given in the world axis system
     * @return a vector containing the orientation for the next step
     */
    private Vector getNextOrientation(float deltaTime, Vector angularAcceleration, Vector currentOrientation, Vector currentRotation){
        //set up the needed variables
        Vector RotationHPR = this.getRotationHPR(currentRotation, currentOrientation);
        Vector angularAccelerationHPR = this.getAngularAccelerationHPR(angularAcceleration, currentOrientation, currentRotation);

        //set up the next rotations
        Vector rotationVelocity = RotationHPR.scalarMult(deltaTime);
        Vector rotationAcceleration = angularAccelerationHPR.scalarMult(deltaTime*deltaTime/2.0f);

        //return the next Orientation
        return currentOrientation.vectorSum(rotationVelocity).vectorSum(rotationAcceleration);
    }


    /**
     * Calculates the rotation vector for the next time interval expressed in the world axis
     * @param deltaTime the time step to be taken
     * @param angularAcceleration the angular acceleration given in the world axis
     * @param currentRotation the rotation vector of the drone, given in the world axis
     * @return a vector containing the next rotation vector given in the world axis
     */
    private Vector getNextRotationVector(float deltaTime, Vector angularAcceleration, Vector currentRotation){
        Vector deltaRotation = angularAcceleration.scalarMult(deltaTime);

        return currentRotation.vectorSum(deltaRotation);
    }

    /**
     * Calculates the new velocity under the assumption that the acceleration remains constant
     * @param deltaTime the time between the steps
     * @param acceleration the (constant) acceleration between the steps given in the world axis system
     * @param currentVelocity the current velocity of the drone given in the world axis system
     * @return a vector containing the velocity of the next time step
     */
    private Vector getNextVelocity(float deltaTime, Vector acceleration, Vector currentVelocity){
        Vector deltaVelocity = acceleration.scalarMult(deltaTime);
        return currentVelocity.vectorSum(deltaVelocity);

    }


    /**
     * Calculates the next position under the assumption that the acceleration remains constant
     * @param deltaTime the time between the steps
     * @param acceleration the acceleration of the drone in the world axis system
     * @param currentPosition the position of the drone in the world axis system
     * @param currentVelocity the velocity of the drone in the world axis system
     * @return a vector containing the position of the next time step
     */
    private Vector getNextPosition(float deltaTime, Vector acceleration, Vector currentPosition, Vector currentVelocity){
        Vector deltaPosVelocityPart = currentVelocity.scalarMult(deltaTime);
        Vector deltaPosAccelerationPart = acceleration.scalarMult(deltaTime*deltaTime/2.0f);

        return currentPosition.vectorSum(deltaPosVelocityPart).vectorSum(deltaPosAccelerationPart);

    }

    /**
     * Calculates the angular acceleration based on the moment, moment of inertia and rotation vector
     * the resulting vector is projected onto the drone axis system
     * @param orientation the orientation of the drone (heading, pitch, roll)
     * @param rotationVector the rotation vector of the drone
     * @return a vector containing the angular acceleration of the drone
     * @author Martijn Sauwens
     */
    private Vector calcAngularAcceleration(Vector orientation, Vector rotationVector, Vector velocity) {
        SquareMatrix inverseInertiaTensor = this.getInertiaTensor().invertDiagonal();
        Vector moment = this.getTotalMomentDrone(orientation, rotationVector, velocity);
        Vector rotationDrone = worldOnDrone(rotationVector, orientation);
        Vector rotationXImpulseMoment = rotationDrone.crossProduct(this.getImpulseMoment(orientation, rotationVector));

        Vector momentDiff = moment.vectorDifference(rotationXImpulseMoment);
        return inverseInertiaTensor.matrixVectorProduct(momentDiff);
    }

    /**
     * calculates the acceleration vector of the drone in the world axis system
     * @param thrustVector the thrust generated by the drone (given in the drone axis system)
     * @param orientation the orientation of the drone
     * @return a vector containing the acceleration of the drone in the world axis system
     */
    private Vector calcAcceleration(Vector thrustVector, Vector orientation, Vector rotation, Vector velocity){
        Vector externalForce = getTotalExternalForcesWorld(thrustVector, orientation, rotation, velocity);
        float totalMass = this.getTotalMass();

        return externalForce.scalarMult(1/totalMass);

    }

    /**
     * Calculates the total external forces on the drone which are: lift, gravity and thrust
     * @param thrustVector the thrust vector of the drone, given in the drone axis-system
     * @param orientation the orientation of the drone (heading, pitch, roll)
     * @return the total external forces on the drone
     * @author Martijn Sauwens
     */
    public Vector getTotalExternalForcesWorld(Vector thrustVector, Vector orientation, Vector rotation, Vector velocity) {

        // calculate the force exerted on the wings
        WingPhysX[] wingArray = this.getWingArray();
        int nbOfWings = wingArray.length;
        Vector[] liftVectors = new Vector[nbOfWings];

        for (int index = 0; index != nbOfWings; index++) {
            liftVectors[index] = wingArray[index].getLift(orientation, rotation, velocity);
        }

        Vector totalLift = Vector.sumVectorArray(liftVectors);

        // transform the thrust vector of the drone to the world axis
        Vector thrust = droneOnWorld(thrustVector, orientation);

        //calculate the scalar value of the gravity working on the drone
        float gravityYComp = - this.getPhysXEngineConfig().getGravity()*this.getTotalMass();
        // get the gravitational force exerted on the drone
        Vector gravity = new Vector(0, gravityYComp, 0);

        // create array containing all the forces exerted on the drone
        Vector[] forceArray = {totalLift, thrust, gravity};

        return Vector.sumVectorArray(forceArray);

    }

    /**
     * Calculates the total moment exerted on the drone in the drone axis system
     * @param orientation the orientation of the drone (heading, pitch, roll)
     * @return a vector containing the total exerted moment on the drone in the drone axis system
     * @author Martijn Sauwens
     * note: the gravity and thrust force are ignored because they are parallel to their force arms
     */
    public Vector getTotalMomentDrone(Vector orientation, Vector rotation, Vector velocity) {
        WingPhysX[] wingArray = this.getWingArray();
        int nbOfWings = wingArray.length;
        //the array containing the lift vectors projected on the drone axis
        Vector[] momentVectorsDrone = new Vector[nbOfWings];

        for (int index = 0; index != nbOfWings; index++) {
            WingPhysX currentWing = wingArray[index];
            Vector liftOnDrone = worldOnDrone(currentWing.getLift(orientation, rotation, velocity), orientation);
            Vector positionWing = currentWing.getRelativePosition();
            Vector momentOnDrone = positionWing.crossProduct(liftOnDrone);
            momentVectorsDrone[index] = momentOnDrone;
        }

        return Vector.sumVectorArray(momentVectorsDrone);
    }

    /**
     * calculates the moment of inertia of the drone on a given point in time, the impulse moment is given in the
     * drone axis system
     * @param orientation the orientation vector of the drone (heading, pitch, roll)
     * @param rotationVector the rotation vector of the drone in the world axis system
     * @return a vector containing the moment of inertia
     * @throws NullPointerException thrown if the Inertia tensor is not initialized
     * @author Martijn Sauwens
     */
    private Vector getImpulseMoment(Vector orientation, Vector rotationVector) throws NullPointerException {
        SquareMatrix inertiaTensor = this.getInertiaTensor();
        if (inertiaTensor == null) {
            throw new NullPointerException();
        }

        //calculate the angular velocity of the drone in the drone axis system
        Vector rotationDrone = worldOnDrone(rotationVector, orientation);

        return inertiaTensor.matrixVectorProduct(rotationDrone);

    }

    /**
     * Calculates the total mass of the drone
     * @return the mass of the wings and the engine
     * @author Martijn Sauwens
     */
    private float getTotalMass(){
        float totalMass = this.getPhysXEngineConfig().getEngineMass();

        WingPhysX[] wingArray = this.getWingArray();
        for(WingPhysX wing: wingArray){
            totalMass += wing.getMass();
        }

        return totalMass;
    }

    /**
     * Calculates the inertia tensor based on the point masses given to the system
     * The inertia tensor is calculated in the drone axis system.
     *
     * @throws IllegalArgumentException thrown if not all the parts of the drone are initialized
     * post: new inertiaTensor == SquareMatrix({Ixx, 0.0f, 0.0f,
     * 0.0f, Iyy, 0.0f,
     * 0.0f, 0.0f, Izz});
     * with Ixx sum(mi*(yi^2 + zi^2), Iyy = mi*(xi^2 + zi^2), Izz = mi*(xi^2 + yi^2)
     * and  mi the mass of the selected point, xi, yi, zi the coordinate of the point mass
     * for more info: https://nl.wikipedia.org/wiki/Traagheidsmoment
     * @author Martijn Sauwens
     */
    private void setInertiaTensor() throws IllegalArgumentException {
        float Ixx = 0;
        float Iyy = 0;
        float Izz = 0;

        if (!this.canCalcInertiaTensor())
            throw new IllegalArgumentException(UNINITIALIZED_POINTMASS);

        WingPhysX[] wingArray = this.getWingArray();

        // calculate the inertia caused by the wings
        for (WingPhysX wing : wingArray) {
            float mass = wing.getMass();
            Vector wingPos = wing.getRelativePosition();
            float xValue = wingPos.getxValue();
            float yValue = wingPos.getyValue();
            float zValue = wingPos.getzValue();

            Ixx += mass * (yValue * yValue + zValue * zValue);
            Iyy += mass * (xValue * xValue + zValue * zValue);
            Izz += mass * (xValue * xValue + yValue * yValue);
        }

        //calculate the inertia caused by the engine
        float engineMass = this.getPhysXEngineConfig().getEngineMass();
        Vector enginePos = this.getEnginePosition();
        float zValueEngine = enginePos.getzValue();


        //the engine is always located on the z axis
        Ixx += engineMass * zValueEngine * zValueEngine;
        Iyy += engineMass * zValueEngine * zValueEngine;

        float[] inertiaArray = {Ixx, 0.0f, 0.0f,
                                0.0f, Iyy, 0.0f,
                                0.0f, 0.0f, Izz};

        this.inertiaTensor = new SquareMatrix(inertiaArray);

    }


    /**
     * checks if the drone is in the right state to calculate the inertia tensor
     *
     * @return true if and only if all the point masses of the drone are initialized and the
     * inertia tensor hasn't been calculated before (immutable character of the tensor)
     * @author Martijn Sauwens
     */
    private boolean canCalcInertiaTensor() {
        if (this.inertiaTensor != null)
            return false;
        if (this.getEnginePosition() == null)
            return false;

        for (WingPhysX wing : this.getWingArray()) {
            if (wing == null)
                return false;
        }

        return true;
    }


    /**
     * sets the engine position based on the configuration of the drone
     *
     * @post the center of mass is (0,0,0) in the drone's axis.
     * @author Martijn Sauwens
     */
    private void setEnginePosition() throws NullPointerException {
        HorizontalWingPhysX horizontalStab = this.getHorizontalStabilizer();
        VerticalWingPhysX verticalStab = this.getVerticalStabilizer();
        float engineMass = this.getPhysXEngineConfig().getEngineMass();

        if (horizontalStab == null || verticalStab == null)
            throw new NullPointerException();

        if (engineMass == 0.0f)
            throw new IllegalArgumentException(UNINITIALIZED_ENGINEMASS);

        float horizontalStabPos = horizontalStab.getRelativePosition().getzValue();
        float verticalStabPos = verticalStab.getRelativePosition().getzValue();
        float horizontalStabMass = horizontalStab.getMass();
        float verticalStabMass = verticalStab.getMass();

        this.enginePosition = new Vector(0, 0, -(horizontalStabMass * horizontalStabPos + verticalStabMass * verticalStabPos) / engineMass);
    }

    private Vector getEnginePosition() {
        return enginePosition;
    }

    /**
     * Creates an array containing all the wings of the drone
     *
     * @return an array containing all the wings of the drone
     * @author Martijn Sauwens
     */
    private WingPhysX[] getWingArray() {
        return new WingPhysX[]{this.getMainRight(), this.getMainLeft(),
                this.getHorizontalStabilizer(), this.getVerticalStabilizer()};
    }

    /**
     * Normalizes the given orientation, with normalization meaning setting
     * the range of the orientation elements to the range [-PI, PI]
     * @param orientation the vector containing the orientation of the drone (heading, pitch, roll)
     * @return a new vector with all elements rescaled to the range [-PI, PI]
     * @author Martijn Sauwens
     */
    private Vector normalizeOrientation(Vector orientation){
        float[] vectorArray = new float[Vector.VECTOR_SIZE];
        for(int index = 0; index != Vector.VECTOR_SIZE; index++){
            float tempValue = orientation.getElementAt(index);
            //first set the value between the range [0, 2PI]
            tempValue = (float) (tempValue%(2*Math.PI));
            //then if the value is larger than PI subtract PI*2
            //so the range becomes [-PI, PI]
            if(tempValue > Math.PI){
                tempValue = (float) (tempValue-Math.PI*2);
            }
            vectorArray[index] = tempValue;
        }

        return new Vector(vectorArray);
    }

    /**
     * checks if the given thrust can be set as the thrust in the engine
     * @param thrust the thrust of the drone
     * @return true if and only if the thrust is in range[0, maxThrust]
     */
    private boolean canHaveAsThrust(float thrust){
        return thrust >= 0 && thrust <= getPhysXEngineConfig().getMaxThrust();
    }



    /**
     * getter for the physics engine configuration
     * @return the configuration of the physics engine
     */
    private AutopilotConfig getPhysXEngineConfig() {
        return physXEngineConfig;
    }

    /**
     * setter for the physics engine configuration
     * @param physXEngineConfig the desired configuration for the physics engine
     */
    private void setPhysXEngineConfig(AutopilotConfig physXEngineConfig) {

        if(!canHaveAsPhysXEngineConfig())
            throw new IllegalArgumentException(ILLEGAL_CONFIG);
        this.physXEngineConfig = physXEngineConfig;
    }

    /**
     * Returns true if and only if the engine is not yet configured
     * @return true if and only if the current engine configuration is a null reference
     */
    public boolean canHaveAsPhysXEngineConfig(){
        return this.getPhysXEngineConfig() == null;
    }


    /**
     * getter for the inertia tensor of the drone
     * @return a square matrix containing the inertia tensor of the drone
     */
    private SquareMatrix getInertiaTensor() {
        return inertiaTensor;
    }

    /**
     * getter for the main right wing of the physics engine
     * @return the main right wing of the physics engine
     */
    private HorizontalWingPhysX getMainRight() {
        return mainRight;
    }

    /**
     * setter for the main right wing of the physics engine
     * @param mainRight the desired main right wing of the physics engine
     */
    public void setMainRight(HorizontalWingPhysX mainRight) {
        this.mainRight = mainRight;
    }

    /**
     * getter for the main left horizontal wing of the physics engine
     * @return the main left wing of the physics engine
     */
    private HorizontalWingPhysX getMainLeft() {
        return mainLeft;
    }

    /**
     * setter for the main left wing of the physics engine
     * @param mainLeft the desired main left wing of the physics engine
     */
    private void setMainLeft(HorizontalWingPhysX mainLeft) {
        this.mainLeft = mainLeft;
    }

    /**
     * getter for the horizontal stabilizer of the physics engine
     * @return the horizontal stabilizer of the physics engine
     */
    private HorizontalWingPhysX getHorizontalStabilizer() {
        return horizontalStabilizer;
    }

    /**
     * setter for the horizontal stabilizr of the physics engine
     * @param horizontalStabilizer the desired horizontal stabilizer
     */
    private void setHorizontalStabilizer(HorizontalWingPhysX horizontalStabilizer) {
        this.horizontalStabilizer = horizontalStabilizer;
    }

    /**
     * Getter for the vertical stabilizer of the physics engine
     * @return the vertical stabilizer of the physics engine
     */
    private VerticalWingPhysX getVerticalStabilizer() {
        return verticalStabilizer;
    }

    /**
     * Setter for the vertical stabilizer physics of the engine
     * @param verticalStabilizer the vertical stabilizer
     */
    private void setVerticalStabilizer(VerticalWingPhysX verticalStabilizer) {
        this.verticalStabilizer = verticalStabilizer;
    }

    public FlightRecorder getFlightRecorder() {
        return flightRecorder;
    }

    public void setFlightRecorder(FlightRecorder flightRecorder) {
        this.flightRecorder = flightRecorder;
    }

    /**
     * Variable that stores the wing physics of the right main wing
     */
    private HorizontalWingPhysX mainRight;
    /**
     * Variable that stores the wing physics of the left main wing
     */
    private HorizontalWingPhysX mainLeft;

    /**
     * Variable that stores the wing physics of the horizontal stabilizer
     */
    private HorizontalWingPhysX horizontalStabilizer;

    /**
     * Variable that stores the wing physics of the vertical stabilizer
     */
    private VerticalWingPhysX verticalStabilizer;

    /**
     * Variable that stores the configuration of the physics engine
     */
    private AutopilotConfig physXEngineConfig;

    /**
     * Variable that stores the inertia tensor of the drone
     */
    private SquareMatrix inertiaTensor;

    /**
     * Variable that stores the engine position of the drone
     */
    private Vector enginePosition;

    /**
     * Variable that stores the flightRecorder
     */
    private FlightRecorder flightRecorder;


    /*
    Error messages
     */
    private final static String THRUST_OUT_OF_RANGE = "The thrust is out of range: [0, this.maxThrust]";
    private final static String INCLINATION_OUT_OF_RANGE = "The inclination is out of range: [0, 2.PI[";
    private final static String VELOCITY_ERROR = "The velocity exceeds the upper limit";
    private final static String WING_EXCEPTION = "the wings are null references or the drone has already wings" +
            "attached to it";
    private final static String UNINITIALIZED_ENGINEMASS = "The mass of the engine is uninitialized";
    private final static String UNINITIALIZED_POINTMASS = "one or more of the point masses of the drone " +
            "have not been initialized yet";
    private final static String ILLEGAL_CONFIG = "The given configuration contains illegal values and or arguments";
    private final static String INVALID_TIMESTEP = "The provided time needs to be strictly positive";
    private final static String AUTOPILOT_CONFIG = "the autopilot has already been initialized";
    private final static String INVALID_CONFIG = "The physics engine is already configured";


    public final static String ALPHA_MODE = "ALPHA_MODE";
    public final static String BETA_MODE = "BETA_MODE";


    public PhysXOptimisations createPhysXOptimisations(){
        return new PhysXOptimisations();
    }

    /**
     * A class used for optimisation problems concerning the physics of the drone.
     * Eg: calculating the optimal velocity and thrust to gain stability
     */
    public class PhysXOptimisations {

        public PhysXOptimisations(){
            // nothing to construct
        }


        public Vector[] balanceDrone(Vector orientation, float mainWingStable, float stabWingStable){
            PhysXEngine.this.getMainLeft().setWingInclination(mainWingStable);
            PhysXEngine.this.getMainRight().setWingInclination(mainWingStable);
            PhysXEngine.this.getHorizontalStabilizer().setWingInclination(stabWingStable);
            PhysXEngine.this.getVerticalStabilizer().setWingInclination(stabWingStable);
            // use interval reduction to find the zero point for the lift, and initialize the thrust to
            // be equal to the "drag" experienced by the aircraft.
            float stepsize = 1.0f;
            float velocity = 0.0f;
            float firstPositive;
            boolean positiveLift = false;
            Vector zeroThrust = new Vector();

            // first get the point where the total external forces are larger than zero
            while(! positiveLift) {
                //System.out.println("external forces " + PhysXEngine.this.getTotalExternalForcesWorld(zeroThrust, orientation, new Vector(), new Vector(0,0, -velocity)));
                //System.out.println("Velocity: " + velocity);
                if(PhysXEngine.this.getTotalExternalForcesWorld(zeroThrust, new Vector(), new Vector(), new Vector(0,0, -velocity)).getyValue() > 0.0f) {
                    positiveLift = true;
                    firstPositive = velocity;
                }else{
                    if(velocity > 1000)
                        throw new IllegalArgumentException();
                    velocity += stepsize;
                }
            }

            velocity = this.findZero(orientation, velocity-stepsize, velocity);
            float desiredThrust = -PhysXEngine.this.getTotalExternalForcesWorld(zeroThrust, orientation, new Vector(), new Vector(0,0, -velocity)).getzValue();
            return new Vector[]{new Vector(0,0,desiredThrust), new Vector(0,0, -velocity)};
        }

        private float findZero(Vector orientation, float lowerBound, float upperBound){

            float epsilon = 1E-6f;
            float nbOfSteps = 10000;
            float prevYValue = Float.MAX_VALUE;
            float velocityCenter = upperBound;
            Vector zeroThrust = new Vector();
            Vector velocityVector = new Vector();

            for(int index = 0; index != nbOfSteps; index++){
                //get the value for this iteration
                velocityCenter = (lowerBound + upperBound)/2.0f;
                velocityVector = new Vector(0.0f, 0.0f, -velocityCenter);
                float yNextValue = PhysXEngine.this.getTotalExternalForcesWorld(zeroThrust, orientation, new Vector(), velocityVector).getyValue();
                //System.out.println(drone.getTotalExternalForcesWorld());

                //check if the precision is good enough
                if(yNextValue == 0.0f){
                    System.out.println("exit with good approx");
                    return velocityCenter;
                // if not replace the borders
                }else{
                    if(yNextValue < 0){
                        lowerBound = velocityCenter;
                        prevYValue = yNextValue;
                    }else{
                        upperBound = velocityCenter;
                        prevYValue = yNextValue;
                    }
                }
            }
            System.out.println("Exit with bad approx");
            System.out.println("Total External Forces: " + PhysXEngine.this.getTotalExternalForcesWorld(zeroThrust, orientation, new Vector(), velocityVector));
            System.out.println("Velocity: " + velocityCenter);
            return velocityCenter;
        }

        public Vector balanceThrust(float stepSize, Vector orientation, Vector rotation, Vector velocity){

            //public Vector getTotalExternalForcesWorld(Vector thrustVector, Vector orientation, Vector rotation, Vector velocity)
            int nbSteps = (int)Math.round(Math.floor(getPhysXEngineConfig().getMaxThrust()/stepSize));
            float bestSize = Float.POSITIVE_INFINITY;
            float bestThrust = 0;
            float currentThrust = 0;

            for(int i = 0;  i != nbSteps; i++){
                Vector externalForce = getTotalExternalForcesWorld(new Vector(0,0, -currentThrust), orientation, rotation, velocity);
                float currentSize = externalForce.getSize();
                if(currentSize < bestSize ){
                    bestThrust = currentThrust;
                }
                currentThrust += i*stepSize;
            }

            return new Vector(0,0, - bestThrust);
        }

        /**
         * Calculates the maximum right wing inclination for the given angle of attack
         * @param orientation the orientation of the drone (heading, pitch, roll)
         * @param rotation the rotation of the drone
         * @param velocity the velocity of the drone (world axis system)
         * @param angleOfAttack the angle of attack wherefore the inclination is calculated
         * @return the maximum inclination of the right wing that is  possible under the given angle of attack
         * @author Martijn Sauwens
         */
        public float getMaxRightMainWingInclination(Vector orientation, Vector rotation, Vector velocity, float angleOfAttack){
            HorizontalWingPhysX rightMain = PhysXEngine.this.getMainRight();
            return calcMaximalHorizontalInclination(orientation, rotation, velocity, angleOfAttack, rightMain);
        }

        /**
         * Calculates the maximum left wing inclination for the given angle of attack
         * @param orientation the orientation of the drone (heading, pitch, roll)
         * @param rotation the rotation of the drone
         * @param velocity the velocity of the drone (world axis system)
         * @param angleOfAttack the angle of attack wherefore the inclination is calculated
         * @return the maximum inclination of the left wing that is  possible under the given angle of attack
         * @author Martijn Sauwens
         */
        public float getMaxLeftMainWingInclination(Vector orientation, Vector rotation, Vector velocity, float angleOfAttack){
            HorizontalWingPhysX leftMain = PhysXEngine.this.getMainLeft();
            return calcMaximalHorizontalInclination(orientation, rotation, velocity, angleOfAttack, leftMain);

        }

        /**
         * Calculates the maximum horizontal stabilizer inclination for the given angle of attack
         * @param orientation the orientation of the drone (heading, pitch, roll)
         * @param rotation the rotation of the drone
         * @param velocity the velocity of the drone (world axis system)
         * @param angleOfAttack the angle of attack wherefore the inclination is calculated
         * @return the maximum inclination of the horizontal stabilizer that is  possible under the given angle of attack
         * @author Martijn Sauwens
         */
        public float getMaxHorStabInclination(Vector orientation, Vector rotation, Vector velocity, float angleOfAttack){
            HorizontalWingPhysX horizontalStab = PhysXEngine.this.getHorizontalStabilizer();
            return calcMaximalHorizontalInclination(orientation, rotation, velocity, angleOfAttack, horizontalStab);
        }

        /**
         * Calculates the maximum vertical stabilizer inclination for the given angle of attack
         * @param orientation the orientation of the drone (heading, pitch, roll)
         * @param rotation the rotation of the drone
         * @param velocity the velocity of the drone (world axis system)
         * @param angleOfAttack the angle of attack wherefore the inclination is calculated
         * @return the maximum inclination of the vertical stabilizer that is  possible under the given angle of attack
         * @author Martijn Sauwens
         */
        public float getMaxVerStabInclination(Vector orientation, Vector rotation, Vector velocity, float angleOfAttack){
            VerticalWingPhysX verticalStab = PhysXEngine.this.getVerticalStabilizer();
            return calcMaximalVerticalInclination(orientation, rotation, velocity, angleOfAttack, verticalStab);
        }


        /**
         * Calculates the maximum permitted inclination for a given angle of attack for a horizontal wing
         * @param orientation the orientation of the drone
         * @param rotation the rotation of the drone
         * @param velocity the velocity of the center of the drone (world axis system)
         * @param angleOfAttack the angle of attack wherefore the inclination is calculated
         * @param wing the horizontal wing of the drone wherefore the inclination is calculated
         * @return the maximum inclination of the horizontal wing that is possible under the given angle of attack
         */
        private float calcMaximalHorizontalInclination(Vector orientation, Vector rotation, Vector velocity,
                                                      float angleOfAttack, HorizontalWingPhysX wing){
            Vector absoluteAirspeed = wing.getAbsoluteVelocity(orientation, rotation, velocity);
            Vector airspeedDrone = PhysXEngine.worldOnDrone(absoluteAirspeed, orientation);

            //System.out.println("Airspeed in drone axis: " + airspeedDrone);

            float yVelocity = airspeedDrone.getyValue();
            float zVelocity = airspeedDrone.getzValue();

            // secondly calculate the inclination permitted for the given angle of attack
            float numerator = (float) (zVelocity*atan(angleOfAttack) + yVelocity);
            float denominator = (float) (yVelocity*atan(angleOfAttack) - zVelocity);

            return (float) atan2(numerator, denominator);
        }

        /**
         * Calculates the maximum permitted inclination for a given angle of attack for a vertical wing
         * @param orientation the orientation of the drone
         * @param rotation the rotation of the drone
         * @param velocity the velocity of the drone (world axis)
         * @param angleOfAttack the angle of attack wherefore the inclination is calculated
         * @param wing the vertical wing of the drone wherefore the inclination is calculated
         * @return the maximum inclination of the vertical wing that is possible under the given angle of attack
         */
        private float calcMaximalVerticalInclination(Vector orientation, Vector rotation, Vector velocity,
                                                    float angleOfAttack, VerticalWingPhysX wing){
            // first get the airspeed
            Vector absoluteAirspeed = wing.getAbsoluteVelocity(orientation, rotation, velocity);
            Vector airspeedDrone = PhysXEngine.worldOnDrone(absoluteAirspeed, orientation);

            float xVelocity = airspeedDrone.getxValue();
            float zVelocity = airspeedDrone.getzValue();

            // secondly calculate the inclination permitted for the given angle of attack
            float numerator = (float) (xVelocity - zVelocity*atan(angleOfAttack));
            float denominator = (float) (zVelocity + xVelocity*atan(angleOfAttack));

            return (float) atan2(numerator, abs(denominator));
        }

    }

}

/*
    // tried to use multi threading for the calculation heaviest application, but too much overhead
    //calculate the next arguments concurrently
    ExecutorService executor = Executors.newFixedThreadPool(2);

    Callable<Vector> accelerationCall = new Callable<Vector>() {
        @Override
        public Vector call() throws Exception {
            return calcAcceleration(thrustVector, orientation, rotation, velocity);
        }
    };

    Callable<Vector> angularAccelerationCall = new Callable<Vector>() {
        @Override
        public Vector call() throws Exception {
            return calcAngularAcceleration(orientation, rotation, velocity);
        }
    };

    //execute both concurrently
    Future<Vector> angularFuture = executor.submit(angularAccelerationCall);
    Future<Vector> accelerationFuture = executor.submit(accelerationCall);

    //initialize the vectors
    Vector acceleration = new Vector();
    Vector angularAcceleration = new Vector();

        try {
                acceleration = accelerationFuture.get();
                angularAcceleration = angularFuture.get();
                } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
                }

                executor.shutdown();
*/