package internal;

import Autopilot.AutopilotConfig;
import Autopilot.AutopilotOutputs;

/**
 * Created by Martijn on 6/11/2017.
 */
public class PhysXEngine {

    /**
     * Constructor for a physics engine
     * @param configuration the configuration of the engine
     */
    public PhysXEngine(AutopilotConfig configuration){

        this.setPhysXEngineConfig(configuration);

        this.setMainRight(new HorizontalWingPhysX(new Vector(configuration.getWingX(),0f, 0f),
                configuration.getWingLiftSlope(), configuration.getWingMass(), configuration.getMaxAOA(), 0));
        this.setMainLeft(new HorizontalWingPhysX(new Vector(-configuration.getWingX(), 0f, 0f),
                configuration.getWingLiftSlope(), configuration.getWingMass(), configuration.getMaxAOA(), 0));
        this.setHorizontalStabilizer(new HorizontalWingPhysX(new Vector(0,0, configuration.getTailSize()),
                configuration.getHorStabLiftSlope(), configuration.getTailMass(), configuration.getMaxAOA(), 0));
        this.setVerticalStabilizer(new VerticalWingPhysX(new Vector(0,0, configuration.getTailSize()),
                configuration.getVerStabLiftSlope(), configuration.getTailMass(), configuration.getMaxAOA(), 0));

        this.setEnginePosition();
        this.setInertiaTensor();


    }

    /**
     * Calculates the next state of the drone for the given input
     * @param deltaTime the time step for the next state
     * @param inputs the outputs generated by the autopilot
     * @param position the position of the drone at moment t
     * @param velocity the velocity of the drone at moment t
     * @param orientation the orientation at moment t
     * @param rotation the rotation at moment t
     * @param INSIGNIFICANCE factor to ignore small drift in the model
     * @return a PhysicsEngineState object containing the state of the drone at moment t + deltaTime
     */
    public PhysicsEngineState getNextStatePhysXEngine(float deltaTime, AutopilotOutputs inputs,  Vector position, Vector velocity, Vector orientation, Vector rotation, float INSIGNIFICANCE){

        //adjust the inclinations of the wings
        this.getMainRight().setWingInclination(inputs.getRightWingInclination());
        this.getMainLeft().setWingInclination(inputs.getLeftWingInclination());
        this.getHorizontalStabilizer().setWingInclination(inputs.getHorStabInclination());
        this.getVerticalStabilizer().setWingInclination(inputs.getVerStabInclination());

        //check if the thrust is valid
        if(!canHaveAsThrust(inputs.getThrust()))
            throw new IllegalArgumentException(THRUST_OUT_OF_RANGE);
        Vector thrustVector = new Vector(0.f, 0.f, -inputs.getThrust());

        // calculate the next position & velocity
        Vector acceleration = this.calcAcceleration(thrustVector, orientation, rotation, velocity);
        Vector nextVelocity = this.getNextVelocity(deltaTime, acceleration, velocity);
        Vector nextPosition = this.getNextPosition(deltaTime, acceleration, position, velocity);

        Vector angularAcceleration = this.calcAngularAcceleration(orientation, rotation, velocity);
        Vector angularAccelerationWorld = droneOnWorld(angularAcceleration, orientation);
        Vector nextRotation = this.getNextRotationVector(deltaTime, angularAccelerationWorld, rotation);
        Vector nextOrientation = this.getNextOrientation(deltaTime, angularAccelerationWorld, orientation, rotation);

        PhysicsEngineState state = new PhysicsEngineState() {
            @Override
            public Vector getPosition() {
               return  position.driftRejection(nextPosition, INSIGNIFICANCE*deltaTime);
            }

            @Override
            public Vector getVelocity() {
                return velocity.driftRejection(nextVelocity, INSIGNIFICANCE*deltaTime);
            }

            @Override
            public Vector getOrientation() {
                return normalizeOrientation(orientation.driftRejection(nextOrientation, INSIGNIFICANCE*deltaTime));
            }

            @Override
            public Vector getRotation() {
                return rotation.driftRejection(nextRotation, INSIGNIFICANCE*deltaTime);
            }
        };

        return state;
    }


    /*
    Transformations
     */
    /**
     * projects a vector of the drone axis on the world axis
     *
     * @param vector the vector to project
     * @param orientation the orientation of the drone (heading, pitch, roll)
     * @return a new vector containing the projection
     * @author Martijn Sauwens
     */
    public static Vector droneOnWorld(Vector vector, Vector orientation) {
        return getDroneToWorldTransformMatrix(orientation).matrixVectorProduct(vector);
    }

    /**
     * projects a vector in the world axis to a vector in the drone axis
     *
     * @param vector the vector to project on the drone axis
     * @param orientation the orientation of the drone (heading, pitch, roll)
     * @return a new vector containing the projection
     * @author Martijn Sauwens
     */
    public static Vector worldOnDrone(Vector vector, Vector orientation) {
        SquareMatrix transform = getDroneToWorldTransformMatrix(orientation);
        SquareMatrix transpose = transform.transpose();

        return transpose.matrixVectorProduct(vector);
    }

    /**
     * Calculates the transformation matrix for the drone to world axis
     * @param orientation the orientation of the drone (heading, pitch, roll)
     * @return a square matrix containing the transformation matrix for the current drone configuration;
     * @author Jasper Callaerts & Martijn Sauwens
     */
    private static SquareMatrix getDroneToWorldTransformMatrix(Vector orientation) {
        SquareMatrix heading = SquareMatrix.getHeadingTransformMatrix(orientation.getxValue());
        SquareMatrix pitch = SquareMatrix.getPitchTransformMatrix(orientation.getyValue());
        SquareMatrix roll = SquareMatrix.getRollTransformMatrix(orientation.getzValue());

        return heading.matrixProduct(pitch).matrixProduct(roll);
    }
    /**
     * Calculates the projection of the provided rotation vector
     * @param rotationVector the rotation vector to be projected
     * @param orientation the orientation of the drone (heading, pitch, roll)
     * @return a vector containing the heading, pitch and roll rotation vector
     * 		   the vector has the following format:
     * 		   Vector(headingRotation, pitchRotation, rollRotation)
     * 		   for more info concering the projection see the individual transformation functions
     * note: see notes on the calculations for clarification
     * @author Martijn Sauwens
     */
    public Vector getRotationHPR(Vector rotationVector, Vector orientation){
        Vector headingRotation = this.getHeadingRotationVector(rotationVector, orientation);
        Vector pitchRotation = this.getPitchRotationVector(rotationVector, orientation);
        Vector rollRotation = this.getRollRotationVector(rotationVector, orientation);

        Vector sumHeadingPitch = headingRotation.vectorSum(pitchRotation);
        return sumHeadingPitch.vectorSum(rollRotation);
    }


    /**
     * Calculates the heading rotation vector component for a given rotation vector
     * the heading vector stands always with the y-axis in the world axis system
     * @param rotationVector the rotation vector to be projected
     * @param orientation the orientation of the drone (heading, pitch, roll)
     * @return a vector containing the heading rotation (given in the same format as the orientation vectors)
     * 		   return new Vector( projectedHeading, 0, 0 )
     * @author Martijn Sauwens
     */
    private Vector getHeadingRotationVector(Vector rotationVector, Vector orientation){
        float heading = orientation.getxValue();
        float pitch = orientation.getyValue();

        float part1 = rotationVector.getyValue();
        float part2 = (float) (rotationVector.getzValue()*Math.cos(heading)*Math.tan(pitch));
        float part3 = (float) (rotationVector.getxValue()*Math.sin(heading)*Math.tan(pitch));

        float result = part1 + part2 + part3;

        return new Vector(result, 0.0f, 0.0f);
    }


    /**
     * Calculates the pitch rotation vector component for a given rotation vector
     * the pitch vector stands parallel to the x axis after the heading transformation
     * has been applied to the world axis system
     * @param rotationVector the rotation vector to be projected
     * @param orientation the orientation of the drone (heading, pitch, roll)
     * @return a vector containing the pitch rotation, given in the heading transformed world axis system
     * 		   return new Vector (0 , projectedPitch, 0)
     * @author Martijn Sauwens
     */
    private Vector getPitchRotationVector(Vector rotationVector, Vector orientation){
        float heading = orientation.getxValue();

        float part1 = (float) (rotationVector.getxValue()*Math.cos(heading));
        float part2 = (float) (- rotationVector.getzValue()*Math.sin(heading));

        float result = part1 + part2;

        return new Vector(0.0f, result, 0.0f);
    }

    /**
     * Calculates the roll rotation vector component for a given rotation vector
     * the roll vector stands parallel to the the z- axis after the heading and the pitch transformation
     * has been applied to the world axis system
     * @param rotationVector the rotation vector to be projected
     * @param orientation the orientation of the drone (heading, pitch, roll)
     * @return a vector containing the roll rotation, given in the double transformed world axis system
     * 		   return new Vector(0, 0, rollRotationVector)
     *
     * @author Martijn Sauwens
     */
    private Vector getRollRotationVector(Vector rotationVector, Vector orientation){
        float heading = orientation.getxValue();
        float pitch = orientation.getyValue();

        float part1 = (float) (rotationVector.getxValue()*Math.sin(heading));
        float part2 = (float) (rotationVector.getzValue()*Math.cos(heading));

        float result = (float) ((part1 + part2)/Math.cos(pitch));

        return new Vector(0.0f, 0.0f, result);

    }

    /**
     * Calculates the angular acceleration in the heading, pitch, roll system for a given
     * angular acceleration vector
     * @param angularAccelerationVector the angular acceleration vector in the world axis system
     * @return a vector of format (HeadingAcceleration, PitchAcceleration, RollAcceleration)
     * @author Martijn Sauwens
     */
    private Vector getAngularAccelerationHPR(Vector angularAccelerationVector, Vector orientation, Vector rotationVector){
        float headingAcceleration = this.getHeadingAngularAcceleration(angularAccelerationVector, orientation, rotationVector);
        float pitchAcceleration = this.getPitchAngularAcceleration(angularAccelerationVector, orientation, rotationVector);
        float rollAcceleration = this.getRollAngularAcceleration(angularAccelerationVector, orientation, rotationVector);

        return new Vector(headingAcceleration, pitchAcceleration, rollAcceleration);
    }

    /**
     * Calculates the heading angular acceleration component for the given angular acceleration vector
     * the heading acceleration vector stands parallel to the y-axis in the world axis system
     * @param angularAccelerationVector the vector containing the angular acceleration given in the
     *                                  world-axis system
     * @param orientation the current orientation of the drone (heading, pitch, roll)
     * @param rotationVector the current rotation vector of the drone, given in the world axis system
     * @return the heading angular acceleration
     * @author Martijn Sauwens
     */
    private float getHeadingAngularAcceleration(Vector angularAccelerationVector, Vector orientation, Vector rotationVector){
        float heading = orientation.getxValue();
        float pitch = orientation.getyValue();
        Vector AAVector = angularAccelerationVector;

        float headingRotation = this.getHeadingRotationVector(rotationVector, orientation).getxValue();
        float pitchRotation = this.getPitchRotationVector(rotationVector, orientation).getyValue();

        //split up in parts for convenience
        float part1 = (float) (AAVector.getyValue() + AAVector.getzValue()*Math.cos(heading)*Math.tan(pitch));
        float part2 = (float) (-rotationVector.getzValue()*headingRotation*Math.sin(heading)*Math.tan(pitch));
        float part3 = (float) (rotationVector.getzValue()*pitchRotation*Math.cos(heading)/(Math.cos(pitch)*Math.cos(pitch)));
        float part4 = (float) (AAVector.getxValue()*Math.sin(heading)*Math.tan(pitch));
        float part5 = (float) (rotationVector.getxValue()*headingRotation*Math.cos(heading)*Math.tan(pitch));
        float part6 = (float) (rotationVector.getxValue()*pitchRotation*Math.sin(heading)/(Math.cos(pitch)*Math.cos(pitch)));

        return part1 + part2 + part3 + part4 + part5 + part6;
    }
    /**
     * Calculates the pitch angular acceleration component for the given angular acceleration vector
     * the pitch acceleration vector stands parallel to the x-axis after the heading transformation
     * of the world axis system
     * @param angularAccelerationVector the vector containing the angular acceleration
     *                                  given in the world-axis system
     * @param orientation the orientation of the drone (heading, pitch, roll)
     * @param rotationVector the rotation of the drone given in the world axis system
     * @return the pitch angular acceleration
     * @author Martijn Sauwens
     */
    private float getPitchAngularAcceleration(Vector angularAccelerationVector, Vector orientation, Vector rotationVector){
        float heading = orientation.getxValue();
        Vector AAVector = angularAccelerationVector;

        float headingRotation = this.getHeadingRotationVector(rotationVector, orientation).getxValue();
        //split up in parts for convenience
        float part1 = (float) (AAVector.getxValue()*Math.cos(heading) - rotationVector.getxValue()*headingRotation*Math.sin(heading));
        float part2 = (float) (- AAVector.getzValue()*Math.sin(heading) - rotationVector.getzValue()*headingRotation*Math.cos(heading));
        return part1 + part2;
    }

    /**
     * Calculates the roll angular acceleration component for the given angular acceleration vector
     * the roll acceleration stands parallel to the z-axis after the heading and the pitch transformation
     * of the world axis system (in that order)
     * @param angularAccelerationVector the vector containing the angular acceleration
     *                                  given in the world-axis system
     * @param orientation the orientation of the drone (heading, pitch, roll)
     * @param rotationVector the rotation vector of the drone, given in the world axis system
     * @return the roll angular acceleration
     * @author Martijn Sauwens
     */
    private float getRollAngularAcceleration(Vector angularAccelerationVector, Vector orientation, Vector rotationVector){
        float heading = orientation.getxValue();
        float pitch = orientation.getyValue();
        Vector AAVector = angularAccelerationVector;

        float headingRotation = this.getHeadingRotationVector(rotationVector, orientation).getxValue();
        float pitchRotation = this.getPitchRotationVector(rotationVector, orientation).getyValue();

        //split up for convenience
        float part1 = (float) (AAVector.getzValue()*Math.cos(heading)/Math.cos(pitch) -
                rotationVector.getzValue()*headingRotation*Math.sin(heading)/Math.cos(pitch));
        float part2 = (float) (rotationVector.getzValue()*pitchRotation*Math.sin(heading)*Math.sin(pitch)/(Math.cos(pitch)*Math.cos(pitch)));
        float part3 = (float) (AAVector.getxValue()*Math.sin(heading)/Math.cos(pitch) + rotationVector.getxValue()
                *headingRotation*Math.cos(heading)/Math.cos(pitch));
        float part4 = (float) (rotationVector.getxValue()*pitchRotation*Math.sin(heading)*Math.sin(pitch)/(Math.cos(pitch)*Math.cos(pitch)));

        return part1 + part2 + part3 + part4;
    }


    /*
    Next state methods
     */

    /**
     * calculates the next orientation based on the current orientation and the angular acceleration
     * @param deltaTime the time step taken
     * @param angularAcceleration the angular acceleration
     * @param currentOrientation the orientation of the drone (heading, pitch, roll)
     * @param currentRotation the rotation vector of the drone, given in the world axis system
     * @return a vector containing the orientation for the next step
     */
    private Vector getNextOrientation(float deltaTime, Vector angularAcceleration, Vector currentOrientation, Vector currentRotation){
        //set up the needed variables
        Vector RotationHPR = this.getRotationHPR(currentRotation, currentOrientation);
        Vector angularAccelerationHPR = this.getAngularAccelerationHPR(angularAcceleration, currentOrientation, currentRotation);

        //set up the next rotations
        Vector rotationVelocity = RotationHPR.scalarMult(deltaTime);
        Vector rotationAcceleration = angularAccelerationHPR.scalarMult(deltaTime*deltaTime/2.0f);

        //return the next Orientation
        return currentOrientation.vectorSum(rotationVelocity).vectorSum(rotationAcceleration);
    }


    /**
     * Calculates the rotation vector for the next time interval expressed in the world axis
     * @param deltaTime the time step to be taken
     * @param angularAcceleration the angular acceleration given in the world axis
     * @param currentRotation the rotation vector of the drone, given in the world axis
     * @return a vector containing the next rotation vector given in the world axis
     */
    private Vector getNextRotationVector(float deltaTime, Vector angularAcceleration, Vector currentRotation){
        Vector deltaRotation = angularAcceleration.scalarMult(deltaTime);

        return currentRotation.vectorSum(deltaRotation);
    }

    /**
     * Calculates the new velocity under the assumption that the acceleration remains constant
     * @param deltaTime the time between the steps
     * @param acceleration the (constant) acceleration between the steps given in the world axis system
     * @param currentVelocity the current velocity of the drone given in the world axis system
     * @return a vector containing the velocity of the next time step
     */
    private Vector getNextVelocity(float deltaTime, Vector acceleration, Vector currentVelocity){
        Vector deltaVelocity = acceleration.scalarMult(deltaTime);
        return currentVelocity.vectorSum(deltaVelocity);

    }


    /**
     * Calculates the next position under the assumption that the acceleration remains constant
     * @param deltaTime the time between the steps
     * @param acceleration the acceleration of the drone in the world axis system
     * @param currentPosition the position of the drone in the world axis system
     * @param currentVelocity the velocity of the drone in the world axis system
     * @return a vector containing the position of the next time step
     */
    private Vector getNextPosition(float deltaTime, Vector acceleration, Vector currentPosition, Vector currentVelocity){
        Vector deltaPosVelocityPart = currentVelocity.scalarMult(deltaTime);
        Vector deltaPosAccelerationPart = acceleration.scalarMult(deltaTime*deltaTime/2.0f);

        return currentPosition.vectorSum(deltaPosVelocityPart).vectorSum(deltaPosAccelerationPart);

    }

    /**
     * Calculates the angular acceleration based on the moment, moment of inertia and rotation vector
     * the resulting vector is projected onto the drone axis system
     * @param orientation the orientation of the drone (heading, pitch, roll)
     * @param rotationVector the rotation vector of the drone
     * @return a vector containing the angular acceleration of the drone
     * @author Martijn Sauwens
     */
    private Vector calcAngularAcceleration(Vector orientation, Vector rotationVector, Vector velocity) {
        SquareMatrix inverseInertiaTensor = this.getInertiaTensor().invertDiagonal();
        Vector moment = this.getTotalMomentDrone(orientation, rotationVector, velocity);
        Vector rotationDrone = worldOnDrone(rotationVector, orientation);
        Vector rotationXImpulseMoment = rotationDrone.crossProduct(this.getImpulseMoment(orientation, rotationVector));

        Vector momentDiff = moment.vectorDifference(rotationXImpulseMoment);
        return inverseInertiaTensor.matrixVectorProduct(momentDiff);
    }

    /**
     * calculates the acceleration vector of the drone in the world axis system
     * @param thrustVector the thrust generated by the drone (given in the drone axis system)
     * @param orientation the orientation of the drone
     * @return a vector containing the acceleration of the drone in the world axis system
     */
    private Vector calcAcceleration(Vector thrustVector, Vector orientation, Vector rotation, Vector velocity){
        Vector externalForce = getTotalExternalForcesWorld(thrustVector, orientation, rotation, velocity);
        float totalMass = this.getTotalMass();

        return externalForce.scalarMult(1/totalMass);

    }

    /**
     * Calculates the total external forces on the drone which are: lift, gravity and thrust
     * @param thrustVector the thrust vector of the drone, given in the drone axis-system
     * @param orientation the orientation of the drone (heading, pitch, roll)
     * @return the total external forces on the drone
     * @author Martijn Sauwens
     */
    public Vector getTotalExternalForcesWorld(Vector thrustVector, Vector orientation, Vector rotation, Vector velocity) {
        System.out.println("Velocity " + velocity);
        // calculate the force exerted on the wings
        WingPhysX[] wingArray = this.getWingArray();
        int nbOfWings = wingArray.length;
        Vector[] liftVectors = new Vector[nbOfWings];

        for (int index = 0; index != nbOfWings; index++) {
            liftVectors[index] = wingArray[index].getLift(orientation, rotation, velocity);
        }

        Vector totalLift = Vector.sumVectorArray(liftVectors);
        System.out.println("total lift " + totalLift);
        // transform the thrust vector of the drone to the world axis
        Vector thrust = droneOnWorld(thrustVector, orientation);

        //calculate the scalar value of the gravity working on the drone
        float gravityYComp = - this.getPhysXEngineConfig().getGravity()*this.getTotalMass();
        // get the gravitational force exerted on the drone
        Vector gravity = new Vector(0, gravityYComp, 0);

        // create array containing all the forces exerted on the drone
        Vector[] forceArray = {totalLift, thrust, gravity};

        return Vector.sumVectorArray(forceArray);

    }

    /**
     * Calculates the total moment exerted on the drone in the drone axis system
     * @param orientation the orientation of the drone (heading, pitch, roll)
     * @return a vector containing the total exerted moment on the drone in the drone axis system
     * @author Martijn Sauwens
     * note: the gravity and thrust force are ignored because they are parallel to their force arms
     */
    public Vector getTotalMomentDrone(Vector orientation, Vector rotation, Vector velocity) {
        WingPhysX[] wingArray = this.getWingArray();
        int nbOfWings = wingArray.length;
        //the array containing the lift vectors projected on the drone axis
        Vector[] momentVectorsDrone = new Vector[nbOfWings];

        for (int index = 0; index != nbOfWings; index++) {
            WingPhysX currentWing = wingArray[index];
            Vector liftOnDrone = worldOnDrone(currentWing.getLift(orientation, rotation, velocity), orientation);
            Vector positionWing = currentWing.getRelativePosition();
            Vector momentOnDrone = positionWing.crossProduct(liftOnDrone);
            momentVectorsDrone[index] = momentOnDrone;
        }

        return Vector.sumVectorArray(momentVectorsDrone);
    }

    /**
     * calculates the moment of inertia of the drone on a given point in time, the impulse moment is given in the
     * drone axis system
     * @param orientation the orientation vector of the drone (heading, pitch, roll)
     * @param rotationVector the rotation vector of the drone in the world axis system
     * @return a vector containing the moment of inertia
     * @throws NullPointerException thrown if the Inertia tensor is not initialized
     * @author Martijn Sauwens
     */
    private Vector getImpulseMoment(Vector orientation, Vector rotationVector) throws NullPointerException {
        SquareMatrix inertiaTensor = this.getInertiaTensor();
        if (inertiaTensor == null) {
            throw new NullPointerException();
        }

        //calculate the angular velocity of the drone in the drone axis system
        Vector rotationDrone = worldOnDrone(rotationVector, orientation);

        return inertiaTensor.matrixVectorProduct(rotationDrone);

    }

    /**
     * Calculates the total mass of the drone
     * @return the mass of the wings and the engine
     * @author Martijn Sauwens
     */
    private float getTotalMass(){
        float totalMass = this.getPhysXEngineConfig().getEngineMass();

        WingPhysX[] wingArray = this.getWingArray();
        for(WingPhysX wing: wingArray){
            totalMass += wing.getMass();
        }

        return totalMass;
    }

    /**
     * Calculates the inertia tensor based on the point masses given to the system
     * The inertia tensor is calculated in the drone axis system.
     *
     * @throws IllegalArgumentException thrown if not all the parts of the drone are initialized
     * post: new inertiaTensor == SquareMatrix({Ixx, 0.0f, 0.0f,
     * 0.0f, Iyy, 0.0f,
     * 0.0f, 0.0f, Izz});
     * with Ixx sum(mi*(yi^2 + zi^2), Iyy = mi*(xi^2 + zi^2), Izz = mi*(xi^2 + yi^2)
     * and  mi the mass of the selected point, xi, yi, zi the coordinate of the point mass
     * for more info: https://nl.wikipedia.org/wiki/Traagheidsmoment
     * @author Martijn Sauwens
     */
    private void setInertiaTensor() throws IllegalArgumentException {
        float Ixx = 0;
        float Iyy = 0;
        float Izz = 0;

        if (!this.canCalcInertiaTensor())
            throw new IllegalArgumentException(UNINITIALIZED_POINTMASS);

        WingPhysX[] wingArray = this.getWingArray();

        // calculate the inertia caused by the wings
        for (WingPhysX wing : wingArray) {
            float mass = wing.getMass();
            Vector wingPos = wing.getRelativePosition();
            float xValue = wingPos.getxValue();
            float yValue = wingPos.getyValue();
            float zValue = wingPos.getzValue();

            Ixx += mass * (yValue * yValue + zValue * zValue);
            Iyy += mass * (xValue * xValue + zValue * zValue);
            Izz += mass * (xValue * xValue + yValue * yValue);
        }

        //calculate the inertia caused by the engine
        float engineMass = this.getPhysXEngineConfig().getEngineMass();
        Vector enginePos = this.getEnginePosition();
        float zValueEngine = enginePos.getzValue();


        //the engine is always located on the z axis
        Ixx += engineMass * zValueEngine * zValueEngine;
        Iyy += engineMass * zValueEngine * zValueEngine;

        float[] inertiaArray = {Ixx, 0.0f, 0.0f,
                                0.0f, Iyy, 0.0f,
                                0.0f, 0.0f, Izz};

        this.inertiaTensor = new SquareMatrix(inertiaArray);

    }


    /**
     * checks if the drone is in the right state to calculate the inertia tensor
     *
     * @return true if and only if all the point masses of the drone are initialized and the
     * inertia tensor hasn't been calculated before (immutable character of the tensor)
     * @author Martijn Sauwens
     */
    private boolean canCalcInertiaTensor() {
        if (this.inertiaTensor != null)
            return false;
        if (this.getEnginePosition() == null)
            return false;

        for (WingPhysX wing : this.getWingArray()) {
            if (wing == null)
                return false;
        }

        return true;
    }


    /**
     * sets the engine position based on the configuration of the drone
     *
     * @post the center of mass is (0,0,0) in the drone's axis.
     * @author Martijn Sauwens
     */
    private void setEnginePosition() throws NullPointerException {
        HorizontalWingPhysX horizontalStab = this.getHorizontalStabilizer();
        VerticalWingPhysX verticalStab = this.getVerticalStabilizer();
        float engineMass = this.getPhysXEngineConfig().getEngineMass();

        if (horizontalStab == null || verticalStab == null)
            throw new NullPointerException();

        if (engineMass == 0.0f)
            throw new IllegalArgumentException(UNINITIALIZED_ENGINEMASS);

        float horizontalStabPos = horizontalStab.getRelativePosition().getzValue();
        float verticalStabPos = verticalStab.getRelativePosition().getzValue();
        float horizontalStabMass = horizontalStab.getMass();
        float verticalStabMass = verticalStab.getMass();

        this.enginePosition = new Vector(0, 0, -(horizontalStabMass * horizontalStabPos + verticalStabMass * verticalStabPos) / engineMass);
    }

    private Vector getEnginePosition() {
        return enginePosition;
    }

    /**
     * Creates an array containing all the wings of the drone
     *
     * @return an array containing all the wings of the drone
     * @author Martijn Sauwens
     */
    private WingPhysX[] getWingArray() {
        return new WingPhysX[]{this.getMainRight(), this.getMainLeft(),
                this.getHorizontalStabilizer(), this.getVerticalStabilizer()};
    }

    /**
     * Normalizes the given orientation, with normalization meaning setting
     * the range of the orientation elements to the range [-PI, PI]
     * @param orientation the vector containing the orientation of the drone (heading, pitch, roll)
     * @return a new vector with all elements rescaled to the range [-PI, PI]
     * @author Martijn Sauwens
     */
    private Vector normalizeOrientation(Vector orientation){
        float[] vectorArray = new float[Vector.VECTOR_SIZE];
        for(int index = 0; index != Vector.VECTOR_SIZE; index++){
            float tempValue = orientation.getElementAt(index);
            //first set the value between the range [0, 2PI]
            tempValue = (float) (tempValue%(2*Math.PI));
            //then if the value is larger than PI subtract PI*2
            //so the range becomes [-PI, PI]
            if(tempValue > Math.PI){
                tempValue = (float) (tempValue-Math.PI*2);
            }
            vectorArray[index] = tempValue;
        }

        return new Vector(vectorArray);
    }

    /**
     * checks if the given thrust can be set as the thrust in the engine
     * @param thrust the thrust of the drone
     * @return true if and only if the thrust is in range[0, maxThrust]
     */
    private boolean canHaveAsThrust(float thrust){
        return thrust >= 0 && thrust <= getPhysXEngineConfig().getMaxThrust();
    }



    /**
     * getter for the physics engine configuration
     * @return the configuration of the physics engine
     */
    private AutopilotConfig getPhysXEngineConfig() {
        return physXEngineConfig;
    }

    /**
     * setter for the physics engine configuration
     * @param physXEngineConfig the desired configuration for the physics engine
     */
    private void setPhysXEngineConfig(AutopilotConfig physXEngineConfig) {

        if(!canHaveAsPhysXEngineConfig())
            throw new IllegalArgumentException(ILLEGAL_CONFIG);
        this.physXEngineConfig = physXEngineConfig;
    }

    /**
     * Returns true if and only if the engine is not yet configured
     * @return true if and only if the current engine configuration is a null reference
     */
    public boolean canHaveAsPhysXEngineConfig(){
        return this.getPhysXEngineConfig() == null;
    }


    /**
     * getter for the inertia tensor of the drone
     * @return a square matrix containing the inertia tensor of the drone
     */
    private SquareMatrix getInertiaTensor() {
        return inertiaTensor;
    }

    /**
     * getter for the main right wing of the physics engine
     * @return the main right wing of the physics engine
     */
    private HorizontalWingPhysX getMainRight() {
        return mainRight;
    }

    /**
     * setter for the main right wing of the physics engine
     * @param mainRight the desired main right wing of the physics engine
     */
    public void setMainRight(HorizontalWingPhysX mainRight) {
        this.mainRight = mainRight;
    }

    /**
     * getter for the main left horizontal wing of the physics engine
     * @return the main left wing of the physics engine
     */
    private HorizontalWingPhysX getMainLeft() {
        return mainLeft;
    }

    /**
     * setter for the main left wing of the physics engine
     * @param mainLeft the desired main left wing of the physics engine
     */
    private void setMainLeft(HorizontalWingPhysX mainLeft) {
        this.mainLeft = mainLeft;
    }

    /**
     * getter for the horizontal stabilizer of the physics engine
     * @return the horizontal stabilizer of the physics engine
     */
    private HorizontalWingPhysX getHorizontalStabilizer() {
        return horizontalStabilizer;
    }

    /**
     * setter for the horizontal stabilizr of the physics engine
     * @param horizontalStabilizer the desired horizontal stabilizer
     */
    private void setHorizontalStabilizer(HorizontalWingPhysX horizontalStabilizer) {
        this.horizontalStabilizer = horizontalStabilizer;
    }

    /**
     * Getter for the vertical stabilizer of the physics engine
     * @return the vertical stabilizer of the physics engine
     */
    private VerticalWingPhysX getVerticalStabilizer() {
        return verticalStabilizer;
    }

    /**
     * Setter for the vertical stabilizer physics of the engine
     * @param verticalStabilizer the vertical stabilizer
     */
    public void setVerticalStabilizer(VerticalWingPhysX verticalStabilizer) {
        this.verticalStabilizer = verticalStabilizer;
    }

    /**
     * Variable that stores the wing physics of the right main wing
     */
    private HorizontalWingPhysX mainRight;
    /**
     * Variable that stores the wing physics of the left main wing
     */
    private HorizontalWingPhysX mainLeft;

    /**
     * Variable that stores the wing physics of the horizontal stabilizer
     */
    private HorizontalWingPhysX horizontalStabilizer;

    /**
     * Variable that stores the wing physics of the vertical stabilizer
     */
    private VerticalWingPhysX verticalStabilizer;

    /**
     * Variable that stores the configuration of the physics engine
     */
    private AutopilotConfig physXEngineConfig;

    /**
     * Variable that stores the inertia tensor of the drone
     */
    private SquareMatrix inertiaTensor;

    /**
     * Variable that stores the engine position of the drone
     */
    private Vector enginePosition;


    /*
    Error messages
     */
    private final static String THRUST_OUT_OF_RANGE = "The thrust is out of range: [0, this.maxThrust]";
    private final static String INCLINATION_OUT_OF_RANGE = "The inclination is out of range: [0, 2.PI[";
    private final static String VELOCITY_ERROR = "The velocity exceeds the upper limit";
    private final static String WING_EXCEPTION = "the wings are null references or the drone has already wings" +
            "attached to it";
    private final static String UNINITIALIZED_ENGINEMASS = "The mass of the engine is uninitialized";
    private final static String UNINITIALIZED_POINTMASS = "one or more of the point masses of the drone " +
            "have not been initialized yet";
    private final static String ILLEGAL_CONFIG = "The given configuration contains illegal values and or arguments";
    private final static String INVALID_TIMESTEP = "The provided time needs to be strictly positive";
    private final static String AUTOPILOT_CONFIG = "the autopilot has already been initialized";
    private final static String INVALID_CONFIG = "The physics engine is already configured";

    /**
     * A class used for optimisation problems concerning the physics of the drone.
     * Eg: calculating the optimal velocity and thrust to gain stability
     */
    public class PhysicsOptimisations{
        public PhysicsOptimisations(){
            // nothing to construct
        }


    public Vector[] balanceDrone(Vector orientation){
        // use interval reduction to find the zero point for the lift, and initialize the thrust to
        // be equal to the "drag" experienced by the aircraft.
        float stepsize = 1.0f;
        float velocity = 0.0f;
        float firstPositive;
        boolean positiveLift = false;
        Vector zeroThrust = new Vector();

        // first get the point where the total external forces are larger than zero
        while(! positiveLift) {
            System.out.println("external forces " + PhysXEngine.this.getTotalExternalForcesWorld(zeroThrust, orientation, new Vector(), new Vector(0,0, -velocity)));
            //System.out.println("Velocity: " + velocity);
            if(PhysXEngine.this.getTotalExternalForcesWorld(zeroThrust, new Vector(), new Vector(), new Vector(0,0, -velocity)).getyValue() > 0.0f) {
                positiveLift = true;
                firstPositive = velocity;
            }else{
                if(velocity > 1000)
                    throw new IllegalArgumentException();
                velocity += stepsize;
            }
        }

        velocity = this.findZero(orientation, velocity-stepsize, velocity);
        float desiredThrust = -PhysXEngine.this.getTotalExternalForcesWorld(zeroThrust, orientation, new Vector(), new Vector(0,0, -velocity)).getzValue();
        return new Vector[]{new Vector(0,0,desiredThrust), new Vector(0,0, -velocity)};
    }

    private float findZero(Vector orientation, float lowerBound, float upperBound){

        float epsilon = 1E-6f;
        float nbOfSteps = 10000;
        float prevYValue = Float.MAX_VALUE;
        float velocityCenter = upperBound;
        Vector zeroThrust = new Vector();
        Vector velocityVector = new Vector();

        for(int index = 0; index != nbOfSteps; index++){
            //get the value for this iteration
            velocityCenter = (lowerBound + upperBound)/2.0f;
            velocityVector = new Vector(0.0f, 0.0f, -velocityCenter);
            float yNextValue = PhysXEngine.this.getTotalExternalForcesWorld(zeroThrust, orientation, new Vector(), velocityVector).getyValue();
            //System.out.println(drone.getTotalExternalForcesWorld());

            //check if the precision is good enough
            if(yNextValue == 0.0f){
                System.out.println("exit with good approx");
                return velocityCenter;
            // if not replace the borders
            }else{
                if(yNextValue < 0){
                    lowerBound = velocityCenter;
                    prevYValue = yNextValue;
                }else{
                    upperBound = velocityCenter;
                    prevYValue = yNextValue;
                }
            }
        }
        System.out.println("Exit with bad approx");
        System.out.println("Total External Forces: " + PhysXEngine.this.getTotalExternalForcesWorld(zeroThrust, orientation, new Vector(), velocityVector));
        System.out.println("Velocity: " + velocityCenter);
        return velocityCenter;
    }

    }

}
